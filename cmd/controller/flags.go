package controller

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/buildkite/agent-stack-k8s/v2/api"
	"github.com/buildkite/agent-stack-k8s/v2/internal/controller/config"
	"github.com/buildkite/agent-stack-k8s/v2/internal/controller/scheduler"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	"sigs.k8s.io/yaml"
)

// CLI represents the command-line interface structure for Kong.
// Pointer types are used for bool, int, and duration fields so we can distinguish
// "not set" (nil) from "explicitly set to zero/false". This allows CLI/env vars
// to override config file values with zero/false values.
// Defaults are applied via newConfigWithDefaults().
//
// Environment variables are auto-generated by Kong from flag names (kebab-case → SCREAMING_SNAKE_CASE).
// For example: --max-in-flight → MAX_IN_FLIGHT, --job-ttl → JOB_TTL
// Only flags with non-standard names or env vars need explicit name= or env= tags.
type CLI struct {
	// name= needed: Go field "ConfigFile" → Kong default "--config-file", but we want "--config"
	ConfigFile string `kong:"name='config',short='f',help='Path to config file'"`

	// Job / Pod settings
	JobTTL                               *time.Duration `kong:"help='Time to retain kubernetes jobs after completion (default: 10m)'"`
	JobActiveDeadlineSeconds             *int           `kong:"help='Maximum number of seconds a kubernetes job is allowed to run before terminating all pods and failing job (default: 21600)'"`
	JobPrefix                            string         `kong:"help='The prefix to use when creating Kubernetes job names (default: buildkite-)'"`
	DefaultTerminationGracePeriodSeconds *int           `kong:"help='Maximum number of seconds a pod will run after being told to terminate, if not otherwise set by podSpec (default: 60)'"`
	Namespace                            string         `kong:"help='Kubernetes namespace to create resources in (default: default)'"`

	// Controller settings
	JobCreationConcurrency *int           `kong:"help='Number of concurrent goroutines to run for converting Buildkite jobs into Kubernetes jobs (default: 25)'"`
	AgentTokenSecret       string         `kong:"help='Name of the Buildkite agent token secret (default: buildkite-agent-token)'"`
	Image                  string         `kong:"help='The image to use for the Buildkite agent'"`
	MaxInFlight            *int           `kong:"help='Max jobs in flight, 0 means no max (default: 25)'"`
	Tags                   []string       `kong:"help='A comma-separated list of agent tags. The \"queue\" tag must be unique (e.g. \"queue=kubernetes,os=linux\")'"`
	Queue                  string         `kong:"help='The Buildkite queue to poll for jobs (overrides the queue tag if set)'"`
	PrometheusPort         *uint16        `kong:"help='Bind port to expose Prometheus /metrics; 0 disables it (default: 0)'"`
	ProfilerAddress        string         `kong:"help='Bind address to expose the pprof profiler (e.g. localhost:6060)'"`
	PollInterval           *time.Duration `kong:"help='Time to wait between polling for new jobs (minimum 1s); note that increasing this causes jobs to be slower to start (default: 1s)'"`
	HTTPTimeout            *time.Duration `kong:"name='http-timeout',help='Timeout for HTTP requests to the Buildkite Agent API (default: 60s)'"`
	PaginationPageSize     *int           `kong:"help='Sets the maximum number of Jobs per page when retrieving Buildkite Jobs to be Scheduled (default: 1000)'"`
	PaginationDepthLimit   *int           `kong:"help='Sets the maximum number of pages when retrieving Buildkite Jobs to be Scheduled. Increasing this value will increase the number of requests made to the Buildkite API and number of Jobs to be scheduled on the Kubernetes Cluster (default: 2)'"`
	QueryResetInterval     *time.Duration `kong:"help='Controls the interval between pagination cursor resets. Increasing this value will increase the number of jobs to be scheduled but also delay picking up any jobs that were missed from the start of the query (default: 10s)'"`
	EnableQueuePause       *bool          `kong:"help='Allow controller to pause processing the jobs when queue is paused on Buildkite'"`
	WorkQueueLimit         *int           `kong:"help='Sets the maximum number of Jobs the controller will hold in the work queue (default: 1000000)'"`

	// name= and env= needed: Go field "K8s..." → Kong default "--k-8-s-..." and "$K_8_S_...", but we want "--k8s-..." and "$K8S_..."
	K8sClientRateLimiterQPS   *int `kong:"name='k8s-client-rate-limiter-qps',env='K8S_CLIENT_RATE_LIMITER_QPS',help='The QPS value of the K8s client rate limiter (default: 10)'"`
	K8sClientRateLimiterBurst *int `kong:"name='k8s-client-rate-limiter-burst',env='K8S_CLIENT_RATE_LIMITER_BURST',help='The burst value of the K8s client rate limiter (default: 20)'"`

	// name= needed: Go field "ImagePullBackOff..." → Kong default "--image-pull-back-off-...", but we want "--image-pull-backoff-..."
	ImagePullBackOffGracePeriod  *time.Duration `kong:"name='image-pull-backoff-grace-period',help='Duration after starting a pod that the controller will wait before considering cancelling a job due to ImagePullBackOff (e.g. when the podSpec specifies container images that cannot be pulled) (default: 30s)'"`
	JobCancelCheckerPollInterval *time.Duration `kong:"help='Controls the interval between job state queries while a pod is still Pending (default: 5s)'"`
	EmptyJobGracePeriod          *time.Duration `kong:"help='Duration after starting a Kubernetes job that the controller will wait before considering failing the job due to a missing pod (e.g. when the podSpec specifies a missing service account) (default: 30s)'"`

	// Image settings
	DefaultImagePullPolicy      corev1.PullPolicy `kong:"help='Configures a default image pull policy for containers that do not specify a pull policy and non-init containers created by the stack itself'"`
	DefaultImageCheckPullPolicy corev1.PullPolicy `kong:"help='Sets a default PullPolicy for image-check init containers, used if an image pull policy is not set for the corresponding container in a podSpec or podSpecPatch'"`

	SkipImageCheckContainers       *bool  `kong:"help='Disable and skip all imagecheck-* init containers'"`
	ImageCheckContainerCPULimit    string `kong:"help='Configures the CPU resource limits for all imagecheck-* containers (default: 200m)'"`
	ImageCheckContainerMemoryLimit string `kong:"help='Configures the memory resource limits for all imagecheck-* containers (default: 128Mi)'"`

	// Security settings
	ProhibitKubernetesPlugin      *bool `kong:"help='Causes the controller to prohibit the kubernetes plugin specified within jobs (pipeline YAML) - enabling this causes jobs with a kubernetes plugin to fail, preventing the pipeline YAML from having any influence over the podSpec'"`
	AllowPodSpecPatchUnsafeCmdMod *bool `kong:"name='allow-pod-spec-patch-unsafe-command-modification',help='Permits PodSpecPatch to modify the command or args fields of stack-provided containers. See the warning in the README before enabling this option'"`

	// Integration test settings (hidden)
	// env= needed: INTEGRATION_TEST_BUILDKITE_TOKEN doesn't match the flag name "buildkite-token"
	BuildkiteToken  string `kong:"name='buildkite-token',hidden,env='INTEGRATION_TEST_BUILDKITE_TOKEN',help='Buildkite API token with GraphQL scopes'"`
	GraphQLEndpoint string `kong:"hidden,help='Buildkite GraphQL endpoint URL'"`

	// Logging settings
	LogFormat       string `kong:"help='Sets the log format. One of \"logfmt\" (for plain/colored text output) or \"json\" (default: logfmt)'"`
	NoColor         *bool  `kong:"help='Disable colored log output (ANSI escape codes). If the output is not a terminal, colors are disabled automatically'"`
	Debug           *bool  `kong:"help='Sets log level to debug. Overrides --log-level if set'"`
	LogLevel        string `kong:"help='Sets the log level. One of \"debug\", \"info\", \"warn\", \"error\". Overridden by the --debug flag if set (default: info)'"`
	LogHTTPPayloads *bool  `kong:"help='Log full HTTP request and response payloads. Only works when log level is debug. WARNING: may log sensitive information including tokens and secrets'"`
}

// applyCLIOverrides applies CLI values to the config when explicitly set.
// Pointer fields allow distinguishing "not set" (nil) from "set to zero/false".
// Uses reflection to iterate over CLI fields and copy to matching Config fields.
// This ensures precedence: defaults < config file < env vars/CLI flags
func applyCLIOverrides(cfg *config.Config, cli *CLI) {
	cfgVal := reflect.ValueOf(cfg).Elem()
	cliVal := reflect.ValueOf(cli).Elem()
	cliType := cliVal.Type()

	for i := range cliType.NumField() {
		cliField := cliVal.Field(i)
		fieldName := cliType.Field(i).Name

		// Skip ConfigFile - it's not a config field
		if fieldName == "ConfigFile" {
			continue
		}

		cfgField := cfgVal.FieldByName(fieldName)
		if !cfgField.IsValid() {
			continue // CLI field doesn't exist in Config
		}

		switch cliField.Kind() {
		case reflect.Ptr:
			// Pointer types (nil = not set)
			if !cliField.IsNil() {
				cfgField.Set(cliField.Elem())
			}
		case reflect.String:
			// String types (empty = not set)
			if cliField.String() != "" {
				cfgField.Set(cliField)
			}
		case reflect.Slice:
			// Slice types (nil = not set, empty = explicitly cleared)
			if !cliField.IsNil() {
				cfgField.Set(cliField)
			}
		}
	}
}

// newConfigWithDefaults returns a config with default values.
func newConfigWithDefaults() *config.Config {
	return &config.Config{
		AgentTokenSecret:                     "buildkite-agent-token",
		Image:                                config.DefaultAgentImage,
		JobPrefix:                            "buildkite-",
		Namespace:                            "default",
		MaxInFlight:                          25,
		JobTTL:                               10 * time.Minute,
		JobActiveDeadlineSeconds:             21600,
		DefaultTerminationGracePeriodSeconds: 60,
		PollInterval:                         time.Second,
		HTTPTimeout:                          api.DefaultHTTPTimeout,
		JobCreationConcurrency:               25,
		K8sClientRateLimiterQPS:              10,
		K8sClientRateLimiterBurst:            20,
		ImagePullBackOffGracePeriod:          30 * time.Second,
		JobCancelCheckerPollInterval:         5 * time.Second,
		EmptyJobGracePeriod:                  30 * time.Second,
		PaginationPageSize:                   1000,
		PaginationDepthLimit:                 2,
		QueryResetInterval:                   10 * time.Second,
		WorkQueueLimit:                       1000000,
		ImageCheckContainerCPULimit:          "200m",
		ImageCheckContainerMemoryLimit:       "128Mi",
		LogFormat:                            "logfmt",
		LogLevel:                             "info",
	}
}

// loadConfigFile reads and parses a config file.
// Returns the parsed config and a set of keys that were present in the file.
// The keys set is used to determine which fields to merge (even if zero-valued).
func loadConfigFile(configFile string) (*config.Config, map[string]struct{}, error) {
	data, err := os.ReadFile(configFile)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read config file: %w", err)
	}

	// First pass: get the set of keys present in the file
	var rawMap map[string]any
	if err := yaml.Unmarshal(data, &rawMap); err != nil {
		return nil, nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	keys := make(map[string]struct{})
	for k := range rawMap {
		keys[k] = struct{}{}
	}

	// Second pass: unmarshal into the config struct
	cfg := &config.Config{}
	if err := unmarshalConfigStrict(data, cfg); err != nil {
		return nil, nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	return cfg, keys, nil
}

// unmarshalConfigStrict unmarshals YAML config data with support for time.Duration fields.
// It returns an error if the config contains unknown fields, ensuring the user is aware
// if any part of their config is being ignored.
//
// We use sigs.k8s.io/yaml because the config contains Kubernetes types (corev1.PodSpec,
// corev1.Volume, etc.) that have custom JSON unmarshalers. The sigs.k8s.io/yaml library
// converts YAML to JSON and then uses encoding/json for unmarshaling, which correctly
// invokes these custom unmarshalers. Standard YAML libraries (like gopkg.in/yaml.v3)
// would not handle these types correctly without custom decode hooks (as was previously
// required with Viper/mapstructure).
func unmarshalConfigStrict(data []byte, cfg *config.Config) error {
	var rawMap map[string]any
	if err := yaml.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	convertDurations(rawMap)

	jsonData, err := json.Marshal(rawMap)
	if err != nil {
		return err
	}

	decoder := json.NewDecoder(bytes.NewReader(jsonData))
	decoder.DisallowUnknownFields()
	return decoder.Decode(cfg)
}

// convertDurations recursively converts duration strings (e.g., "5m", "30s") to nanoseconds.
func convertDurations(m map[string]any) {
	durationFields := map[string]struct{}{
		"job-ttl":                          {},
		"poll-interval":                    {},
		"http-timeout":                     {},
		"query-reset-interval":             {},
		"image-pull-backoff-grace-period":  {},
		"job-cancel-checker-poll-interval": {},
		"empty-job-grace-period":           {},
	}

	for key, value := range m {
		switch v := value.(type) {
		case string:
			if _, ok := durationFields[key]; ok {
				if d, err := time.ParseDuration(v); err == nil {
					m[key] = int64(d)
				}
			}
		case map[string]any:
			convertDurations(v)
		}
	}
}

// mergeConfigFromFile merges file config values into the base config.
// The keys map indicates which fields were present in the file, allowing
// zero values (like max-in-flight: 0) to override defaults.
// Uses reflection to iterate over fields based on their JSON tags.
func mergeConfigFromFile(base, file *config.Config, keys map[string]struct{}) {
	baseVal := reflect.ValueOf(base).Elem()
	fileVal := reflect.ValueOf(file).Elem()
	baseType := baseVal.Type()

	for i := range baseType.NumField() {
		field := baseType.Field(i)
		jsonTag := strings.Split(field.Tag.Get("json"), ",")[0]
		if jsonTag == "" || jsonTag == "-" {
			continue
		}
		if _, ok := keys[jsonTag]; ok {
			baseVal.Field(i).Set(fileVal.Field(i))
		}
	}
}

// validateConfig validates the config after all sources have been merged.
func validateConfig(cfg *config.Config) error {
	if err := validate.Struct(cfg); err != nil {
		return err
	}

	if cfg.PodSpecPatch != nil {
		if err := validatePodSpecPatch(cfg.PodSpecPatch, cfg.AllowPodSpecPatchUnsafeCmdMod); err != nil {
			return fmt.Errorf("invalid pod spec patch: %w", err)
		}
	}

	if _, err := resource.ParseQuantity(cfg.ImageCheckContainerCPULimit); err != nil {
		return fmt.Errorf("invalid CPU resource limit defined: %s", cfg.ImageCheckContainerCPULimit)
	}

	if _, err := resource.ParseQuantity(cfg.ImageCheckContainerMemoryLimit); err != nil {
		return fmt.Errorf("invalid memory resource limit defined: %s", cfg.ImageCheckContainerMemoryLimit)
	}

	if cfg.DefaultResourceClassName != "" {
		if cfg.ResourceClasses == nil {
			return fmt.Errorf("default-resource-class-name %q specified but no resource-classes defined", cfg.DefaultResourceClassName)
		}
		if _, exists := cfg.ResourceClasses[cfg.DefaultResourceClassName]; !exists {
			return fmt.Errorf("default-resource-class-name %q not found in resource-classes", cfg.DefaultResourceClassName)
		}
	}

	return nil
}

func validatePodSpecPatch(podSpec *corev1.PodSpec, allowCmdMod bool) error {
	for idx, c := range podSpec.Containers {
		if c.Image != strings.ToLower(c.Image) {
			return fmt.Errorf("container image for container at index %d contains uppercase letters: %s", idx, c.Image)
		}

		if !allowCmdMod && (len(c.Command) != 0 || len(c.Args) != 0) {
			return fmt.Errorf("container at index %d (image: %s): %w", idx, c.Image, scheduler.ErrNoCommandModification)
		}
	}

	return nil
}
